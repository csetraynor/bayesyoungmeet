lines(t,PETD.lhr.hat[1,],lwd=3,type='s')
lines(t,PETD.lhr[best.fit.lhr[3],],lwd=3,type='s',col='grey40')
curve(log(hr(x)),from=0,to=1,add=TRUE,lwd=3,lty=2)
text(.28, 3.9, paste("RISE =",formatC(round(RISE.lhr[3],2),format='f',digits=2)),cex=1.4)
dev.off()
#PLTD log-hazard ratio
pdf(paste("PLTDlhr",scen,".pdf",sep=""),family='serif')
par(mfrow=c(1,1),mar=c(2.7,3.2,.2,.2),las=1,mgp=c(1.5,.5,0),cex.lab=1.5,cex=2.5)
curve(log(hr(x)),main=" ",xlab=expression(t),ylab=expression(paste("log{h(t|1)/h(t|0)}")),ylim=c(-2.5,4),col='white')
polygon(c(c(t[1],rep(t[-1],each=2)),rev(c(rep(t[-length(t)],each=2),t[length(t)]))),
c(c(rep(PLTD.lhr.hat[3,-length(t)],each=2),PLTD.lhr.hat[3,length(t)]),c(rev(rep(PLTD.lhr.hat[2,-1],each=2)),PLTD.lhr.hat[2,1])),col='grey60',border='grey60')
lines(t,PLTD.lhr.hat[1,],lwd=3)
lines(t,PLTD.lhr[best.fit.lhr[5],],lwd=3,col='grey40')
curve(log(hr(x)),from=0,to=1,add=TRUE,lwd=3,lty=2)
text(.28, 3.9, paste("RISE =",formatC(round(RISE.lhr[5],2),format='f',digits=2)),cex=1.4)
dev.off()
########################################################################
# Table 1: Distributional summaries of individual estimate RISE values #
########################################################################
CoxPH.RISEs = sapply(CoxPH.lhr,function(x) sqrt(mean((x-log(hr(t)))**2)))
PEPH.RISEs = sapply(PEPH.lhr,function(x) sqrt(mean((x-log(hr(t)))**2)))
PETD.RISEs = apply(PETD.lhr,1,function(x) sqrt(mean((x-log(hr(t)))**2)))
PLPH.RISEs = sapply(PLPH.lhr,function(x) sqrt(mean((x-log(hr(t)))**2)))
PLTD.RISEs = apply(PLTD.lhr,1,function(x) sqrt(mean((x-log(hr(t)))**2)))
#Show Results
round(t(apply(rbind(CoxPH.RISEs,PEPH.RISEs,PETD.RISEs,PLPH.RISEs,PLTD.RISEs),1,function(x) c(mean(x),sd(x),quantile(x,c(.025,.25,.5,.75,.975))) )),2)
#Limit to t in [0,0.50]
CoxPH.RISEs = sapply(CoxPH.lhr,function(x) sqrt(mean((x-log(hr(t[1:5000])))**2)))
PEPH.RISEs = sapply(PEPH.lhr,function(x) sqrt(mean((x-log(hr(t[1:5000])))**2)))
PETD.RISEs = apply(PETD.lhr[,1:5000],1,function(x) sqrt(mean((x-log(hr(t[1:5000])))**2)))
PLPH.RISEs = sapply(PLPH.lhr,function(x) sqrt(mean((x-log(hr(t[1:5000])))**2)))
PLTD.RISEs = apply(PLTD.lhr[,1:5000],1,function(x) sqrt(mean((x-log(hr(t[1:5000])))**2)))
round(t(apply(rbind(CoxPH.RISEs,PEPH.RISEs,PETD.RISEs,PLPH.RISEs,PLTD.RISEs),1,function(x) c(mean(x),sd(x),quantile(x,c(.025,.25,.5,.75,.975))) )),2)
sim = function(N,K,scen){
inverse = function (f, lower = -100, upper = 100){
function (y) uniroot((function (x) f(x) - y), lower = lower, upper = upper)[1]
}
#True Hazard in Control Group
hc = function(t) 1.5*sin(pi*t) + 1
Hc = function(t) -1.5*cos(pi*t)/pi + 1.5/pi + t
Hc.inv = inverse(function(t) ifelse(t < 1, Hc(t) , 2*(t-1) + Hc(1)) , 0, 100)
if(scen==1){
#Time-Dependent Scenario Hazard and Cumulative Hazard Specifications
ht = function(t) 4*(.5*cos(pi*t+pi/2) + 1.5/(t+1) - .2) #Time-Dependent Scenario
Ht = function(t) 4*(.5*cos(pi*t)/pi + 1.5*log(t+1) - .2*t - 1/(2*pi)) #Time-Dependent Scenario
}
if(scen==2){
#Time-Independent Scenario Hazard and Cumulative Hazard Specifications
ht = function(t) hc(t)*exp(1) #Time-Independent Scenario
Ht = function(t) Hc(t)*exp(1) #Time-Independent Scenario
}
Ht.inv = inverse(function (t) ifelse(t < 1, Ht(t), 2*(t-1) + Ht(1)) , 0, 100)
hr = function(x){  ht(x)/hc(x) }
#Generate Data
trt = rbinom(N,1,.5)
#trt = rbinom(N,1,.5)-.5
u = runif(N)
tc = as.vector(unlist(sapply(-log(u),function(z) Hc.inv(z))))
tt = as.vector(unlist(sapply(-log(u),function(z) Ht.inv(z))))
c = runif(N,0,5)
y = ifelse(trt==0,tc,tt)
t = pmin(y,c,rep(1,N))
delta = ifelse(y==t,1,0)
#Time Axis Partition
tilde.t = 0:K/K
####################
## Cox's PH Model ##
####################
cox.fit = coxph(Surv(t,delta)~trt)
##################################
## Piece
#Write parameter estimtates to files
write.table(rbind(round(cox.fit$coeff,4)),paste("CoxPHres",scen,".txt",sep=""),row.names=FALSE,col.names=FALSE,sep=',',append=TRUE)
}
sim(100,10,10)
library(R2jags);library(survival)
sim(100,10,10)
library(survival)
sim(100,10,10)
runif(0.01, 100)
?runif
runif(min = 0.01, max= 100)
runif(n = 1, min = 0.01, max= 100)
#---Set initial values---#
gen_inits <- function(M) {
function()
list(
baseline = rnorm(1),
baseline_sigma = runif(n = 1, min = 0.01, max= 100),
tau_s_bg_raw = 0.1*abs(rnorm(1)),
tau_bg_raw = array(abs(rnorm(M)), dim = c(M)),
beta_bg_raw = array(rnorm(M), dim = c(M))
)
}
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
gen_stan_data <- function(data){
stan_data <- list(
N = nrow(data),
S = length(unique(longdata$id)),
"T" = max(data$t),
M=M,
s = as.integer(data$id),
t = data$t,
event = as.integer(data$deceased),
x = array(matrix(c(data$continuos, data$discrete), ncol=M),
dim=c(nrow(data), M)),
obs_t = data$os_months
)
}
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
#---Set initial values---#
gen_inits <- function(M) {
function()
list(
baseline_sigma = runif(n = 1, min = 0.01, max= 100),
tau_s_bg_raw = 0.1*abs(rnorm(1)),
tau_bg_raw = array(abs(rnorm(M)), dim = c(M)),
beta_bg_raw = array(rnorm(M), dim = c(M))
)
}
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
nChain <- 1
stanfile <- 'pem_unstructured.stan'
rstan_options(auto_write = TRUE)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 1000,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
#----Convergence review -----#
print(simulated_fit)
#-----Run Stan-------#
nChain <- 1
gen_inits <- function(M) {
function()
list(
log_baseline_mu = rnorm(1),
baseline_sigma = abs(rcauchy(n = 1, 0, 2)),
log_baseline_raw = rnorm(length(t_dur)),
tau_s_bg_raw = 0.1*abs(rnorm(1)),
tau_bg_raw = array(abs(rnorm(M)), dim = c(M)),
beta_bg_raw = array(rnorm(M), dim = c(M))
)
}
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits(M = M),
iter = 100,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta_bg", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
rlogis(n=1, 0, 2)
gen_inits(M = M)
gen_stan_data(longdata)
#----Load libraries---#
library(purrr)
library(httr)
library(readr)
library(survival)
library(rstan)
library(spBayesSurv)
library(pracma)
library(assertthat)
library(cgdsr)
suppressMessages(library(dplyr))
library(ggplot2)
require(ggfortify)
theme_set(theme_bw())
library(VIM)
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
set.seed(342)
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
# tau = c(seq(0, 300, by = 90), seq(300, 800, by = 100)) #time in months
# test_baseline <- exp(-4)*rev(seq(0.1, 1, by = 0.1))
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(2.5, 2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
## plot KM curve from simulated data
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
autoplot(survival::survfit(Surv(os_months, os_deceased) ~ 1,
data = sim_data
), conf.int = F) +
ggtitle('Simulated KM curve')
#------ long data format ----#
#set t_obs
t_obs <- sim_data %>% dplyr::select(os_months) %>%
unlist() %>% sort()
sim_data <- sim_data %>% arrange(os_months)
longdata <- survival::survSplit(Surv(time = os_months,
event = deceased) ~ . ,
cut = t_obs, data = (sim_data %>%
mutate(deceased = os_status == "DECEASED")))
#create time point id
longdata <- longdata %>%
group_by(id) %>%
mutate(t = seq(n())) %>%
ungroup()
M = length(test_beta)
gen_stan_data <- function(data){
stan_data <- list(
N = nrow(data),
S = length(unique(longdata$id)),
"T" = max(data$t),
M=M,
s = as.integer(data$id),
t = data$t,
event = as.integer(data$deceased),
x = array(matrix(c(data$continuos, data$discrete), ncol=M),
dim=c(nrow(data), M)),
obs_t = data$os_months
)
}
gen_inits <- function(M) {
function()
list(
log_baseline_mu = rnorm(1),
baseline_sigma = log(abs(rnorm(1))),
log_baseline_raw = rnorm(length(t_dur)),
tau_s_bg_raw = 0.1*abs(rnorm(1)),
tau_bg_raw = array(abs(rnorm(M)), dim = c(M)),
beta_bg_raw = array(rnorm(M), dim = c(M))
)
}
gen_stan_data(longdata)
View(longdata)
longdata <- survival::survSplit(Surv(time = os_months,
event = deceased) ~ . ,
cut = t_obs, data = (sim_data %>%
mutate(deceased = os_status == "DECEASED")))
View(longdata)
deceased = os_status == "DECEASED")))%>%
arrange(id, os_months)
deceased = os_status == "DECEASED")))%>%
dplyr::arrange(id, os_months)
#create time point id
longdata <- longdata %>%
dplyr::arrange(id, os_months)  %>%
group_by(id) %>%
mutate(t = seq(n())) %>%
ungroup()
View(longdata)
#----Generate stan data----#
M = length(test_beta)
gen_stan_data <- function(data){
stan_data <- list(
N = nrow(data),
S = length(unique(longdata$id)),
"T" = max(data$t),
M=M,
s = as.integer(data$id),
t = data$t,
event = as.integer(data$deceased),
x = array(matrix(c(data$continuos, data$discrete), ncol=M),
dim=c(nrow(data), M)),
obs_t = data$os_months
)
}
#---Set initial values---#
gen_inits <- function(M) {
function()
list(
log_baseline_mu = rnorm(1),
baseline_sigma = log(abs(rnorm(1))),
log_baseline_raw = rnorm(length(t_dur)),
tau_s_bg_raw = 0.1*abs(rnorm(1)),
tau_bg_raw = array(abs(rnorm(M)), dim = c(M)),
beta_bg_raw = array(rnorm(M), dim = c(M))
)
}
dotR <- file.path(Sys.getenv("HOME"), ".R")
if (!file.exists(dotR)) dir.create(dotR)
M <- file.path(dotR, "Makevars")
if (!file.exists(M)) file.create(M)
