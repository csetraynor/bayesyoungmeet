lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(exp(n,  rate = exp(-3)))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = 1/100))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
set.seed(342)
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
# tau = c(seq(0, 300, by = 90), seq(300, 800, by = 100)) #time in months
# test_baseline <- exp(-4)*rev(seq(0.1, 1, by = 0.1))
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(rexp(n,  rate = exp(-3)))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = 1/100))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
set.seed(342)
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
# tau = c(seq(0, 300, by = 90), seq(300, 800, by = 100)) #time in months
# test_baseline <- exp(-4)*rev(seq(0.1, 1, by = 0.1))
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
View(sim_data)
log(rexp(100,  rate = exp(-3)))
log(1-runif(100))
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
# tau = c(seq(0, 300, by = 90), seq(300, 800, by = 100)) #time in months
# test_baseline <- exp(-4)*rev(seq(0.1, 1, by = 0.1))
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
coxph(Surv(os_months, os_deceased) ~ continuos + discrete,
data = sim_data
)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
coxph(Surv(os_months, os_deceased) ~ continuos + discrete,
data = sim_data
)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
coxph(Surv(os_months, os_deceased) ~ continuos + discrete,
data = sim_data
)
sim_data
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = 1/100))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = 1/100))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
library(purrr)
library(httr)
library(readr)
library(survival)
library(rstan)
library(spBayesSurv)
library(pracma)
library(assertthat)
library(cgdsr)
suppressMessages(library(dplyr))
library(ggplot2)
require(ggfortify)
theme_set(theme_bw())
library(VIM)
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = exp(-3)))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
str(X)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = exp(-3)))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
autoplot(survival::survfit(Surv(os_months, os_deceased) ~ 1,
data = sim_data
), conf.int = F) +
ggtitle('Simulated KM curve')
pem_sim_data <- function(n, tau, beta, lambda, X, ...){
#format check
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
X <- array(matrix(as.numeric(X)), dim = c(n, length(beta)))
str(X)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(tau)
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,n))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = runif(n) * rexp(n = n, rate = exp(-2)))   %>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
test_n = 100
test_tau = c(seq(0, 1200, length.out = test_n))
test_baseline <- exp(-3)*runif(test_n - 1 , 0, 1)
X = matrix(c(rnorm(100), sample(c(0,1), 100, replace = T)), ncol=2)
test_beta = c(4, -2)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
autoplot(survival::survfit(Surv(os_months, os_deceased) ~ 1,
data = sim_data
), conf.int = F) +
ggtitle('Simulated KM curve')
test_beta = c(3, 5)
sim_data <-  pem_sim_data( beta = test_beta,
X = X,
tau = test_tau,
lambda = test_baseline,
n = test_n
)
sim_data <-
sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
autoplot(survival::survfit(Surv(os_months, os_deceased) ~ 1,
data = sim_data
), conf.int = F) +
ggtitle('Simulated KM curve')
tau <- sim_data %>% select(os_months) %>% unlist %>% unique %>%
sort()
if(tau[1] != 0){
tau <- c(0, tau)
}
t_obs <- as.numeric(sim_data %>% select(os_months) %>% unlist %>% sort())
t_dur <- diff(c(0, t_obs))
longdata <- survival::survSplit(Surv(time = os_months, event = deceased) ~ . ,
cut = tau, data = (sim_data %>%
mutate(deceased = os_status == "DECEASED"))) %>%
arrange(id, os_months)
longdata <- longdata %>%
group_by(id) %>%
mutate(t = seq(n()),
t_dur = os_months - tstart) %>%
ungroup()
M = length(test_beta)
gen_stan_data <- function(data){
stan_data <- list(
N = nrow(data),
S = length(unique(longdata$t)),
"T" = dplyr::n_distinct(data$t),
M=M,
s = array(as.integer(data$id)),
t = data$t,
event = as.integer(data$deceased),
x = array(matrix(c(data$continuos, data$discrete), ncol=M), dim=c(nrow(data), M)),
t_obs = t_obs,
t_dur = t_dur
)
}
gen_inits <- function() {
list(
beta = rcauchy(M, location = 0 , scale = 2),
log_baseline_mu = rnorm(1),
baseline_sigma = abs(rnorm(1)),
log_baseline_raw = rnorm(length(t_dur))
)
}
nChain <- 4
stanfile <- 'pem_unstructured.stan'
rstan_options(auto_write = TRUE)
simulated_fit <- stan(stanfile,
data = gen_stan_data(longdata),
init = gen_inits,
iter = 2000,
cores = min(nChain, parallel::detectCores()),
seed = 7327,
chains = nChain,
pars = c("beta", "baseline", "lp__")
#control = list(adapt_delta = 0.9, max_treedepth = 15)
)
