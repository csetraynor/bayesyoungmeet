t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(.l = list(pp_lambda, pp_beta),
.f = ~ pem_sim_data(estimates = .l,
tau = tau,
n = test_n,
X = X
))
x <- list(1, 10, 100)
y <- list(1, 2, 3)
z <- list(5, 50, 500)
pmap(list(x, y, z), function(a, b ,c) a / (b + c))
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
print("beta =");
str(beta)
print("lambda")
str(lambda)
#prognostic index
mu = exp (X[,1:2] %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
beta <- as.vector(beta)
lambda<- as.vector(lambda)
print("beta =");
str(beta)
print("lambda")
str(lambda)
#prognostic index
mu = exp (X[,1:2] %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
str(X)
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
print("beta =");
str(beta)
print("lambda")
str(lambda)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
dt = diff(c(0,tau, Inf))
length(dt)
min(tau)
dt
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
print("beta =");
str(beta)
print("lambda")
str(lambda)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau))
# or dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
# print("beta =");
# str(beta)
# print("lambda")
# str(lambda)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau))
# or dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
pem_sim_data <- function(n, tau, lambda, beta, X, ...){
# str(estimates)
#
# lambda <- estimates[[1]]
# beta <- estimates[[2]]
beta <- as.vector(as.numeric(beta))
lambda<- as.vector(as.numeric(lambda))
print("beta =");
str(beta)
print("lambda")
str(lambda)
#prognostic index
mu = exp (X %*% beta )
#extract first interval baseline hazard
lambda0 <- lambda[1]
#compute relative hazard for each interval respect to the first
rel_base_risk <- lambda/lambda0
rel_risk = lapply(mu, "*" , rel_base_risk)
#caculate duration
dt = diff(c(0,tau))
# or dt = diff(c(0,tau, Inf))
assertthat::assert_that(length(dt) == length(lambda))
#create a helping matrix
LD <- matrix(0, nrow = length(tau), ncol = length(rel_base_risk))
LD[lower.tri(LD)] <- 1;
#compute log survival
logsurv <- log(1-runif(n))
#compute log survival for each interval tau
lsm = lapply(rel_risk, function(x) -lambda0 * as.vector(LD %*% (x*dt)))
t <- (rep(NA,100))
#find appropiate time interval
t = mapply(function(x, y, z) {
for (i in seq_along(lambda)) {
t = ifelse(x[i]>=z & z>x[i+1], tau[i] + (x[i] - z)/lambda0/y[i], t)
}
return(t)
} , x = lsm, y = rel_risk , z = as.list(logsurv)
)
sim.data <- data_frame(surv_months = t) %>%
mutate(os_status = ifelse(is.na(surv_months), 'LIVING', 'DECEASED'),
surv_months = ifelse(is.na(surv_months), tau[length(tau)], surv_months),
id = seq(n),
censor_months = rexp(n = n, rate = 1/100))%>%
dplyr::mutate(os_status = ifelse(surv_months < censor_months & os_status != 'LIVING',
'DECEASED', 'LIVING'
),
os_months = ifelse(surv_months < censor_months  & os_status != 'LIVING',
surv_months, censor_months
)
) %>%   cbind(X) %>%
rename("continuos" = "1", "discrete" = "2")
return(sim.data)
}
pp_newdata <-
purrr::pmap(list(pp_lambda, pp_beta),
function(a,b) {pem_sim_data(lambda = a,
beta = b,
tau = tau,
n = test_n,
X = X)
} )
## ----single-value-alpha--------------------------------------------------
alpha_raw <- 0.2
tau_al <- 10
log_alpha <- alpha_raw * tau_al
alpha <- exp(log_alpha)
print(alpha)
## ----dist-alpha----------------------------------------------------------
alpha_raw <- rnorm(1000, 0, 1)
tau_al <- 10
log_alpha <- alpha_raw * tau_al
alpha <- exp(log_alpha)
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha)) +
geom_density() +
scale_x_log10(labels = scientific)
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha)) +
geom_density() +
scale_x_log10(labels = "scientific")
library(labeling)
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha)) +
geom_density() +
scale_x_log10(labels = scientific)
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha)) +
geom_density() +
scale_x_log10()
## ----dist-alpha-vs-raw---------------------------------------------------
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha, y = alpha_raw)) +
geom_density2d() +
scale_x_log10(labels = scientific)
## ----dist-alpha-vs-raw---------------------------------------------------
ggplot(data.frame(alpha = alpha, alpha_raw = alpha_raw),
aes(x = alpha, y = alpha_raw)) +
geom_density2d() +
scale_x_log10()
log(9.41e-12)
knitr::opts_chunk$set(echo = TRUE,
message = FALSE,
warning = FALSE,
fig.width = 6,
fig.height = 6)
## ----sim-pp-survdata-----------------------------------------------------
## cumulative survival rate for each posterior draw
pp_survdata <-
pp_newdata %>%
purrr::map(~ dplyr::mutate(., os_deceased = os_status == 'DECEASED')) %>%
purrr::map(~ survival::survfit(Surv(os_months, os_deceased) ~ 1, data = .)) %>%
purrr::map(fortify)
library(purrr)
library(httr)
library(readr)
library(survival)
library(rstan)
library(spBayesSurv)
library(pracma)
library(assertthat)
library(cgdsr)
suppressMessages(library(dplyr))
library(ggplot2)
require(ggfortify)
theme_set(theme_bw())
library(VIM)
## ----sim-pp-survdata-----------------------------------------------------
## cumulative survival rate for each posterior draw
pp_survdata <-
pp_newdata %>%
purrr::map(~ dplyr::mutate(., os_deceased = os_status == 'DECEASED')) %>%
purrr::map(~ survival::survfit(Surv(os_months, os_deceased) ~ 1, data = .)) %>%
purrr::map(fortify)
## summarize cum survival for each unit time (month), summarized at 95% confidence interval
pp_survdata_agg <-
pp_survdata %>%
purrr::map(~ dplyr::mutate(., time_group = floor(time))) %>%
dplyr::bind_rows() %>%
dplyr::group_by(time_group) %>%
dplyr::summarize(surv_mean = mean(surv)
, surv_p50 = median(surv)
, surv_lower = quantile(surv, probs = 0.025)
, surv_upper = quantile(surv, probs = 0.975)
) %>%
dplyr::ungroup()
## summarize cum survival for each unit time (month), summarized at 95% confidence interval
pp_survdata_agg <-
pp_survdata %>%
purrr::map(~ dplyr::mutate(., time_group = floor(time))) %>%
dplyr::bind_rows() %>%
dplyr::group_by(time_group) %>%
dplyr::summarize(surv_mean = mean(surv)
, surv_p50 = median(surv)
, surv_lower = quantile(surv, probs = 0.025)
, surv_upper = quantile(surv, probs = 0.975)
) %>%
dplyr::ungroup()
## ----sim-plot-ppcheck----------------------------------------------------
## km-curve for test data
test_data_kmcurve <-
fortify(
survival::survfit(
Surv(os_months, os_deceased) ~ 1,
data = sim_data %>%
dplyr::mutate(os_deceased = os_status == 'DECEASED')
)) %>%
dplyr::mutate(lower = surv, upper = surv)
ggplot(pp_survdata_agg %>%
dplyr::mutate(type = 'posterior predicted values') %>%
dplyr::rename(surv = surv_p50, lower = surv_lower, upper = surv_upper, time = time_group) %>%
bind_rows(test_data_kmcurve %>% dplyr::mutate(type = 'actual data')),
aes(x = time, group = type, linetype = type)) +
geom_line(aes(y = surv, colour = type)) +
geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2) +
xlim(c(0, 200))
test_data_kmcurve
